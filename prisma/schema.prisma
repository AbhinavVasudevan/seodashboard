generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                String    @id @default(cuid())
  email             String    @unique
  name              String?
  password          String    @default("")
  role              UserRole  @default(WRITER)
  isActive          Boolean   @default(true)
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  requestedArticles Article[] @relation("RequestedArticles")
  writtenArticles   Article[] @relation("WrittenArticles")
  brands            Brand[]

  @@map("users")
}

model Brand {
  id                String     @id @default(cuid())
  name              String
  domain            String?
  description       String?
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt
  semrushProjectId  String?
  semrushCampaignId String?
  semrushLastSync   DateTime?
  userId            String
  apps              App[]
  articles          Article[]
  backlinks         Backlink[]
  user              User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  keywords          Keyword[]

  @@map("brands")
}

model App {
  id           String        @id @default(cuid())
  name         String
  platform     Platform
  country      String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  brandId      String
  rankings     AppRanking[]
  brand        Brand         @relation(fields: [brandId], references: [id], onDelete: Cascade)
  keywords     Keyword[]
  rankTrackers RankTracker[]

  @@map("apps")
}

model AppRanking {
  id        String   @id @default(cuid())
  keyword   String
  country   String
  rank      Int
  score     Int?
  traffic   Int?
  date      DateTime
  createdAt DateTime @default(now())
  appId     String
  app       App      @relation(fields: [appId], references: [id], onDelete: Cascade)

  @@unique([appId, keyword, country, date])
  @@map("app_rankings")
}

model Keyword {
  id        String           @id @default(cuid())
  keyword   String
  country   String
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  brandId   String?
  appId     String?
  rankings  KeywordRanking[]
  app       App?             @relation(fields: [appId], references: [id], onDelete: Cascade)
  brand     Brand?           @relation(fields: [brandId], references: [id], onDelete: Cascade)

  @@unique([brandId, keyword, country])
  @@unique([appId, keyword, country])
  @@map("keywords")
}

model KeywordRanking {
  id           String   @id @default(cuid())
  position     Int
  url          String?
  traffic      Int?
  searchVolume Int?
  difficulty   Int?
  cpc          Float?
  date         DateTime
  createdAt    DateTime @default(now())
  keywordId    String
  keyword      Keyword  @relation(fields: [keywordId], references: [id], onDelete: Cascade)

  @@unique([keywordId, date])
  @@map("keyword_rankings")
}

model RankTracker {
  id          String               @id @default(cuid())
  keyword     String
  country     String
  domain      String
  isActive    Boolean              @default(true)
  lastChecked DateTime?
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
  appId       String
  rankings    RankTrackerHistory[]
  app         App                  @relation(fields: [appId], references: [id], onDelete: Cascade)

  @@unique([appId, keyword, country, domain])
  @@map("rank_trackers")
}

model RankTrackerHistory {
  id            String      @id @default(cuid())
  position      Int
  url           String?
  traffic       Int?
  searchVolume  Int?
  difficulty    Int?
  cpc           Float?
  competition   Float?
  trend         Int?
  date          DateTime
  createdAt     DateTime    @default(now())
  rankTrackerId String
  rankTracker   RankTracker @relation(fields: [rankTrackerId], references: [id], onDelete: Cascade)

  @@unique([rankTrackerId, date])
  @@map("rank_tracker_history")
}

model Backlink {
  id               String         @id @default(cuid())
  rootDomain       String
  referringPageUrl String
  dr               Int?
  traffic          Int?
  targetUrl        String
  anchor           String?
  dofollow         Boolean        @default(true)
  status           BacklinkStatus
  price            Float?
  builtOn          DateTime?
  supplierEmail    String?
  liveFor          Int?
  invoice          String?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  brandId          String
  brand            Brand          @relation(fields: [brandId], references: [id], onDelete: Cascade)

  @@map("backlinks")
}

model Article {
  id              String        @id @default(cuid())
  slNo            String        @unique
  requestedById   String
  writerId        String?
  articleType     ArticleType
  brandId         String
  topicTitle      String
  gameProvider    String?
  primaryKeyword  String?
  finalWordCount  Int?
  documentUrl     String?
  status          ArticleStatus @default(SUBMITTED)
  rejectionReason String?
  pageName        String?
  language        String?
  url             String?
  pageType        String?
  contentUrl      String?
  originalWc      Int?
  writer          String?
  sentDate        DateTime?
  publishDate     DateTime?
  seoCheck        Boolean       @default(false)
  images          Int?
  aiScore         Float?
  plagiarismScore Float?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  brand           Brand         @relation(fields: [brandId], references: [id], onDelete: Cascade)
  requestedBy     User          @relation("RequestedArticles", fields: [requestedById], references: [id])
  writtenBy       User?         @relation("WrittenArticles", fields: [writerId], references: [id])

  @@map("articles")
}

enum Platform {
  ANDROID
  IOS
}

enum BacklinkStatus {
  PENDING
  PUBLISHED
  REJECTED
  EXPIRED
}

enum ArticleType {
  ARTICLE
  CATEGORY
  APP_REVIEW
  GAME_REVIEW
  GUEST_POST
  BRAND_REVIEW
}

enum ArticleStatus {
  SUBMITTED
  REJECTED
  ACCEPTED
  UNPUBLISHED
  SENT_TO_DEV
  PUBLISHED
}

enum UserRole {
  ADMIN
  SEO
  WRITER
}
