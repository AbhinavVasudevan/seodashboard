generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                String          @id @default(cuid())
  email             String          @unique
  name              String?
  password          String          @default("")
  role              UserRole        @default(WRITER)
  isActive          Boolean         @default(true)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  requestedArticles Article[]       @relation("RequestedArticles")
  writtenArticles   Article[]       @relation("WrittenArticles")
  brands            Brand[]
  blockedDomains    BlockedDomain[]

  @@map("users")
}

model Brand {
  id                String              @id @default(cuid())
  name              String
  domain            String?
  description       String?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  semrushProjectId  String?
  semrushCampaignId String?
  semrushLastSync   DateTime?
  userId            String
  apps              App[]
  articles          Article[]
  backlinks         Backlink[]
  backlinkDeals     BrandBacklinkDeal[]
  user              User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  keywords          Keyword[]

  @@index([userId])
  @@map("brands")
}

model App {
  id           String        @id @default(cuid())
  name         String
  platform     Platform
  country      String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  brandId      String
  rankings     AppRanking[]
  brand        Brand         @relation(fields: [brandId], references: [id], onDelete: Cascade)
  keywords     Keyword[]
  rankTrackers RankTracker[]

  @@index([brandId])
  @@map("apps")
}

model AppRanking {
  id        String   @id @default(cuid())
  keyword   String
  country   String
  rank      Int
  score     Int?
  traffic   Int?
  date      DateTime
  createdAt DateTime @default(now())
  appId     String
  app       App      @relation(fields: [appId], references: [id], onDelete: Cascade)

  @@unique([appId, keyword, country, date])
  @@index([appId])
  @@index([date])
  @@map("app_rankings")
}

model Keyword {
  id        String           @id @default(cuid())
  keyword   String
  country   String
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  brandId   String?
  appId     String?
  rankings  KeywordRanking[]
  app       App?             @relation(fields: [appId], references: [id], onDelete: Cascade)
  brand     Brand?           @relation(fields: [brandId], references: [id], onDelete: Cascade)

  @@unique([brandId, keyword, country])
  @@unique([appId, keyword, country])
  @@index([brandId])
  @@index([appId])
  @@map("keywords")
}

model KeywordRanking {
  id           String   @id @default(cuid())
  position     Int
  url          String?
  traffic      Int?
  searchVolume Int?
  difficulty   Int?
  cpc          Float?
  date         DateTime
  createdAt    DateTime @default(now())
  keywordId    String
  keyword      Keyword  @relation(fields: [keywordId], references: [id], onDelete: Cascade)

  @@unique([keywordId, date])
  @@index([keywordId])
  @@index([date])
  @@map("keyword_rankings")
}

model RankTracker {
  id          String               @id @default(cuid())
  keyword     String
  country     String
  domain      String
  isActive    Boolean              @default(true)
  lastChecked DateTime?
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
  appId       String
  rankings    RankTrackerHistory[]
  app         App                  @relation(fields: [appId], references: [id], onDelete: Cascade)

  @@unique([appId, keyword, country, domain])
  @@index([appId])
  @@map("rank_trackers")
}

model RankTrackerHistory {
  id            String      @id @default(cuid())
  position      Int
  url           String?
  traffic       Int?
  searchVolume  Int?
  difficulty    Int?
  cpc           Float?
  competition   Float?
  trend         Int?
  date          DateTime
  createdAt     DateTime    @default(now())
  rankTrackerId String
  rankTracker   RankTracker @relation(fields: [rankTrackerId], references: [id], onDelete: Cascade)

  @@unique([rankTrackerId, date])
  @@map("rank_tracker_history")
}

model Backlink {
  id                      String               @id @default(cuid())
  rootDomain              String
  referringPageUrl        String
  referringPageTitle      String?
  dr                      Int?                 // Domain Rating
  ur                      Int?                 // URL Rating
  domainTraffic           Int?
  targetUrl               String
  anchor                  String?
  linkType                String?              // dofollow, nofollow, ugc, sponsored
  content                 String?              // text, image, form, frame
  platform                String?
  firstSeen               String?
  lastSeen                String?
  publishDate             DateTime?            // When the backlink was published
  price                   Float?
  paypalInvoice           String?              // PayPal invoice URL or ID
  articleCode             String?              // Article/reference code
  remarks                 String?
  createdAt               DateTime             @default(now())
  updatedAt               DateTime             @updatedAt
  brandId                 String
  brand                   Brand                @relation(fields: [brandId], references: [id], onDelete: Cascade)
  linkDirectoryDomainId   String?
  linkDirectoryDomain     LinkDirectoryDomain? @relation(fields: [linkDirectoryDomainId], references: [id])

  @@index([brandId])
  @@index([linkDirectoryDomainId])
  @@map("backlinks")
}

model Article {
  id              String        @id @default(cuid())
  slNo            String        @unique
  requestedById   String
  writerId        String?
  articleType     ArticleType
  brandId         String
  topicTitle      String
  gameProvider    String?
  primaryKeyword  String?
  finalWordCount  Int?
  documentUrl     String?
  status          ArticleStatus @default(SUBMITTED)
  rejectionReason String?
  pageName        String?
  language        String?
  url             String?
  pageType        String?
  contentUrl      String?
  originalWc      Int?
  writer          String?
  sentDate        DateTime?
  publishDate     DateTime?
  seoCheck        Boolean       @default(false)
  images          Int?
  aiScore         Float?
  plagiarismScore Float?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  brand           Brand         @relation(fields: [brandId], references: [id], onDelete: Cascade)
  requestedBy     User          @relation("RequestedArticles", fields: [requestedById], references: [id])
  writtenBy       User?         @relation("WrittenArticles", fields: [writerId], references: [id])

  @@index([brandId])
  @@index([status])
  @@index([requestedById])
  @@map("articles")
}

enum Platform {
  ANDROID
  IOS
}


enum ArticleType {
  ARTICLE
  CATEGORY
  APP_REVIEW
  GAME_REVIEW
  GUEST_POST
  BRAND_REVIEW
}

enum ArticleStatus {
  SUBMITTED
  REJECTED
  ACCEPTED
  UNPUBLISHED
  SENT_TO_DEV
  PUBLISHED
  LIVE
}

enum UserRole {
  ADMIN
  SEO
  WRITER
}

// ==========================================
// LINK DIRECTORY - MASTER DOMAIN TABLE
// ==========================================

model LinkDirectoryDomain {
  id              String              @id @default(cuid())
  rootDomain      String              @unique
  exampleUrl      String?             // One example URL from this domain
  domainRating    Int?
  domainTraffic   Int?
  nofollow        Boolean             @default(false)
  contactedOn     DateTime?
  contactMethod   ContactMethod?
  contactEmail    String?
  contactFormUrl  String?
  remarks         String?

  // Supplier/Deal info
  supplierName    String?             // Contact person name
  supplierEmail   String?             // Supplier email (different from contact email for outreach)
  currentPrice    Float?              // Current negotiated price per link
  currency        String?             @default("USD")

  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  // Relations
  backlinks       Backlink[]
  prospects       BacklinkProspect[]
  priceHistory    DomainPriceHistory[]

  @@index([rootDomain])
  @@map("link_directory_domains")
}

// Price history for domain deals - tracks when prices change
model DomainPriceHistory {
  id                    String              @id @default(cuid())
  linkDirectoryDomainId String
  linkDirectoryDomain   LinkDirectoryDomain @relation(fields: [linkDirectoryDomainId], references: [id], onDelete: Cascade)
  price                 Float
  effectiveFrom         DateTime            @default(now())
  notes                 String?             // e.g., "Price increase", "Negotiated discount"
  createdAt             DateTime            @default(now())

  @@index([linkDirectoryDomainId])
  @@map("domain_price_history")
}

// ==========================================
// BACKLINK DIRECTORY MODELS
// ==========================================

model BacklinkProspect {
  id                      String               @id @default(cuid())
  referringPageUrl        String               @unique
  rootDomain              String
  domainRating            Int?
  domainTraffic           Int?
  nofollow                Boolean              @default(false)
  contactedOn             DateTime?
  contactMethod           ContactMethod?
  contactEmail            String?
  contactFormUrl          String?
  remarks                 String?
  content                 String?
  status                  ProspectStatus       @default(NOT_CONTACTED)
  source                  String?
  createdAt               DateTime             @default(now())
  updatedAt               DateTime             @updatedAt
  brandDeals              BrandBacklinkDeal[]
  linkDirectoryDomainId   String?
  linkDirectoryDomain     LinkDirectoryDomain? @relation(fields: [linkDirectoryDomainId], references: [id])

  @@index([status])
  @@index([rootDomain])
  @@index([linkDirectoryDomainId])
  @@map("backlink_prospects")
}

model AhrefsImport {
  id                  String    @id @default(cuid())
  referringPageTitle  String?
  referringPageUrl    String
  language            String?
  platform            String?
  httpCode            Int?
  domainRating        Int?
  urlRating           Int?
  domainTraffic       Int?
  referringDomains    Int?
  linkedDomains       Int?
  externalLinks       Int?
  pageTraffic         Int?
  keywords            Int?
  targetUrl           String?
  anchor              String?
  linkType            String?
  contentType         String?
  nofollow            Boolean   @default(false)
  ugc                 Boolean   @default(false)
  sponsored           Boolean   @default(false)
  firstSeen           DateTime?
  lastSeen            DateTime?
  importedAt          DateTime  @default(now())
  importBatchId       String
  competitorDomain    String
  isProspect          Boolean   @default(false)

  @@map("ahrefs_imports")
}

model BrandBacklinkDeal {
  id               String            @id @default(cuid())
  brandId          String
  brand            Brand             @relation(fields: [brandId], references: [id], onDelete: Cascade)
  prospectId       String?
  prospect         BacklinkProspect? @relation(fields: [prospectId], references: [id])
  referringPageUrl String
  linkUrl          String
  linkAnchor       String?
  domainRating     Int?
  linkType         String?
  price            Float?
  status           DealStatus        @default(PENDING)
  remarks          String?
  publishedOn      DateTime?
  expiresOn        DateTime?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  @@unique([brandId, referringPageUrl])
  @@index([brandId])
  @@index([status])
  @@map("brand_backlink_deals")
}

enum ContactMethod {
  EMAIL
  CONTACT_FORM
  SOCIAL_MEDIA
  OTHER
}

enum ProspectStatus {
  NOT_CONTACTED
  CONTACTED
  RESPONDED
  NEGOTIATING
  DEAL_LOCKED
  REJECTED
  NO_RESPONSE
}

enum DealStatus {
  PENDING
  APPROVED
  LIVE
  EXPIRED
  CANCELLED
}

// ==========================================
// DOMAIN CATEGORIZATION (Spam, Free Links, etc.)
// ==========================================

model BlockedDomain {
  id          String            @id @default(cuid())
  domain      String            @unique  // Root domain (e.g., "v9181004.xyz")
  type        BlockedDomainType @default(SPAM)
  reason      String?                    // Additional notes
  blockedById String?
  blockedBy   User?             @relation(fields: [blockedById], references: [id])
  createdAt   DateTime          @default(now())

  @@index([domain])
  @@index([type])
  @@map("blocked_domains")
}

enum BlockedDomainType {
  SPAM           // Black hat SEO, link farms, PBNs - always hidden
  FREE_AFFILIATE // Affiliate sites linking for commission without payment - can toggle
  FREE_LINK      // Organic/natural links - visible but tagged
}
